\import BSn
\import Equiv
\import Function
\import Logic
\import Logic.Unique
\import Meta
\import Paths
\import Data.Fin
\import Paths.Meta
\import Set
\import Data.Sigma
\import Data.Or
\import Equiv.Sigma
\import Equiv.Univalence
\import Homotopy.Pushout

-- These are functions that I'd like to have in the standard library

\func SigmaPropPath {A : \Type} {B : A -> \Type} (isPropB : \Pi (a : A) -> isProp (B a))
                    {u v : \Sigma (a : A) (B a)} (q : u.1 = v.1) : u = v
  => exts (q, isPropB _ _ _)
-- This is almost contr-left from Equiv.Sigma, but for prop instead of contr

\func TruncPmap2 {A B C : \Type} (t1 : TruncP A) (t2 : TruncP B) (f : A -> B -> C) :
  TruncP C \elim t1, t2
  | inP a1, inP a2 => inP (f a1 a2)

\func TruncPrec2 {A B C : \Type} (t1 : TruncP A) (t2 : TruncP B) (f : A -> B -> TruncP C)
  : TruncP C \elim t1, t2
  | inP a1, inP a2 => f a1 a2

\lemma TruncPelim {A : \Type} {P : TruncP A -> \Type}
                 (pr : \Pi (y : TruncP A) -> isProp (P y)) (f : \Pi (a : A) -> P (inP a)) (x : TruncP A) : P x =>
  TruncP.remove (pr x) (rec f x) \where {
  \lemma rec (f : \Pi (a : A) -> P (inP a)) (y : TruncP A) : TruncP (P y) \elim y
    | inP a => inP (f a)
}

-- This is basically flip, but using just flip doesn't work
\func funExt- {A : \Type} {B : A -> \Type} {f g : \Pi (a : A) -> B a}
              (p : f = g) (a : A) : f a = g a =>
  \lam i => p i a

\func eqvFun {A B : \Type} (e : Equiv {A} {B}) : A -> B => e

-- Doesn't work when it's not stated implicitly
\lemma not-isProp {A : \Type} : isProp (Not A) => prop-isProp

\func exists! (A : \Type) (B : A -> \Type) : \Type => Contr (\Sigma (x : A) (B x))

\func emptyFin0 : Fin 0 = Empty => iso f g sec ret \where {
  \func f (_ : Fin 0) : Empty
  \func g (_ : Empty) : Fin 0
  \func ret (x : Empty) : f (g x) = x
  \func sec (x : Fin 0) : g (f x) = x
}

\func contrFin1 : Contr (Fin 1) => Contr.make
  (Fin.fromNat 0)
  lem \where {
    \func lem (a : Fin 1) : Fin.fromNat {0} 0 = a
      | 0 => idp
  }

\func funcToUnit {A : \Type} : (A -> \Sigma) = (\Sigma) => iso
  (\lam _ => ())
  (\lam _ _ => ())
  (\lam _ => ext)
  (\lam _ => idp)

\func isContrEqUnit {X : \Type} (pr : Contr X) : X = (\Sigma) => iso
  (\lam _ => ())
  (\lam _ => pr.center)
  pr.contraction
  (\lam _ => idp)

\func Pushoutelim {A B C : \Type} {f : A -> B} {g : A -> C} {Z : PushoutData f g -> \Type}
                  (lm : \Pi (b : B) -> Z (pinl b))
                  (rm : \Pi (c : C) -> Z (pinr c))
                  (gm : \Pi (a : A) -> Path (\lam i => Z (pglue a i)) (lm (f a)) (rm (g a)))
                  (x : PushoutData f g) : Z x \elim x
  | pinl b => lm b
  | pinr c => rm c
  | pglue a => gm a

\func notI (i : I) : I => inv (\lam j => j) i \where {
  \func notILeft : notI left = right => idp
  \func notIRight : notI right = left => idp
}

\func fin2Equiv : Equiv {Fin 2} {Fin 2} = Fin 2 => iso f g sec ret \where {
  \func f (eq : Equiv {Fin 2} {Fin 2}) : Fin 2 => eq 0
  \func g (_ : Fin 2) : Equiv {Fin 2} {Fin 2}
    | 0 => idEquiv
    | 1 => notBS2.notFin2Eq
  \func fin2Inv (a : Fin 2) : Or (a = 0) (a = 1)
    | 0 => inl idp
    | 1 => inr idp
  \func fNot (eq : Equiv {Fin 2} {Fin 2}) : f eq = notBS2.notFin2 (eq 1) =>
    \case fin2Inv (f eq), fin2Inv (eq 1) \with {
      | inl a, inl a1 => \case Equiv.isInj (a1 *> inv a) \with {}
      | inl a, inr b => rewrite a (rewrite b idp)
      | inr b, inl a => rewrite b (rewrite a idp)
      | inr b, inr b1 => \case Equiv.isInj (b1 *> inv b) \with {}
    }

  \func seca (eq : Equiv {Fin 2} {Fin 2}) (a : Fin 2) : g (f eq) a = eq a \elim a
    | 0 => \case fin2Inv (eq 0) \with {
      | inl a => rewrite a idp
      | inr b => rewrite b idp
    }
    | 1 => \case fin2Inv (eq 1) \with {
      | inl a => rewrite fNot (rewrite a idp)
      | inr b => rewrite fNot (rewrite b idp)
    }

  \func sec (eq : Equiv {Fin 2} {Fin 2}) : g (f eq) = eq => run {
    Equiv.equals,
    ext,
    seca eq
  }
  \func ret (x : Fin 2) : f (g x) = x
    | 0 => idp
    | 1 => idp
}