\import Equiv
\import Function
\import Logic
\import Logic.Unique
\import Meta
\import Paths
\import Data.Fin
\import Paths.Meta
\import Set
\import Data.Sigma
\import Equiv.Sigma
\import Equiv.Univalence
\import Homotopy.Pushout

-- These are functions that I'd like to have in the standard library

\func SigmaPropPath {A : \Type} {B : A -> \Type} (isPropB : \Pi (a : A) -> isProp (B a))
                    {u v : \Sigma (a : A) (B a)} (q : u.1 = v.1) : u = v
  => exts (q, isPropB _ _ _)
-- This is almost contr-left from Equiv.Sigma, but for prop instead of contr

\func TruncPmap2 {A B C : \Type} (t1 : TruncP A) (t2 : TruncP B) (f : A -> B -> C) :
  TruncP C \elim t1, t2
  | inP a1, inP a2 => inP (f a1 a2)

\func TruncPrec2 {A B C : \Type} (t1 : TruncP A) (t2 : TruncP B) (f : A -> B -> TruncP C)
  : TruncP C \elim t1, t2
  | inP a1, inP a2 => f a1 a2

-- This is basically flip, but using just flip doesn't work
\func funExt- {A : \Type} {B : A -> \Type} {f g : \Pi (a : A) -> B a}
              (p : f = g) (a : A) : f a = g a =>
  \lam i => p i a

\func eqvFun {A B : \Type} (e : Equiv {A} {B}) : A -> B => e

-- Doesn't work when it's not stated implicitly
\lemma not-isProp {A : \Type} : isProp (Not A) => prop-isProp

\func exists! (A : \Type) (B : A -> \Type) : \Type => Contr (\Sigma (x : A) (B x))

\func emptyFin0 : Fin 0 = Empty => iso f g sec ret \where {
  \func f (_ : Fin 0) : Empty
  \func g (_ : Empty) : Fin 0
  \func ret (x : Empty) : f (g x) = x
  \func sec (x : Fin 0) : g (f x) = x
}

\func contrFin1 : Contr (Fin 1) => Contr.make
  (Fin.fromNat 0)
  lem \where {
    \func lem (a : Fin 1) : Fin.fromNat {0} 0 = a
      | 0 => idp
  }

\func funcToUnit {A : \Type} : (A -> \Sigma) = (\Sigma) => iso
  (\lam _ => ())
  (\lam _ _ => ())
  (\lam _ => ext)
  (\lam _ => idp)

\func isContrEqUnit {X : \Type} (pr : Contr X) : X = (\Sigma) => iso
  (\lam _ => ())
  (\lam _ => pr.center)
  pr.contraction
  (\lam _ => idp)

\func Pushoutelim {A B C : \Type} {f : A -> B} {g : A -> C} {Z : PushoutData f g -> \Type}
                  (lm : \Pi (b : B) -> Z (pinl b))
                  (rm : \Pi (c : C) -> Z (pinr c))
                  (gm : \Pi (a : A) -> Path (\lam i => Z (pglue a i)) (lm (f a)) (rm (g a)))
                  (x : PushoutData f g) : Z x \elim x
  | pinl b => lm b
  | pinr c => rm c
  | pglue a => gm a